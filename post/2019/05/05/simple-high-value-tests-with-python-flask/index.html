<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Simple high value tests with Python Flask - CINAQ</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Simple high value tests with Python Flask">
<meta itemprop="description" content="After 6 years developing Python Flask applications, mainly REST API&rsquo;s, in 2019 I still could not find any good articles about how to develop high value tests for Python Flask based applications. That is going to change today!
First I will give my opinion on testing and methodology, followed by a demo case to illustrate high value testing with actual code. Feel free to skip all the boring reading and head directly over to the code on Github.">
<meta itemprop="datePublished" content="2019-05-05T01:11:03&#43;01:00" />
<meta itemprop="dateModified" content="2019-05-05T01:11:03&#43;01:00" />
<meta itemprop="wordCount" content="1677">



<meta itemprop="keywords" content="python,flask,python-flask,testing,tests,rest,AAA,quality,TDD," /><meta property="og:title" content="Simple high value tests with Python Flask" />
<meta property="og:description" content="After 6 years developing Python Flask applications, mainly REST API&rsquo;s, in 2019 I still could not find any good articles about how to develop high value tests for Python Flask based applications. That is going to change today!
First I will give my opinion on testing and methodology, followed by a demo case to illustrate high value testing with actual code. Feel free to skip all the boring reading and head directly over to the code on Github." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cinaq.com/post/2019/05/05/simple-high-value-tests-with-python-flask/" />
<meta property="article:published_time" content="2019-05-05T01:11:03+01:00" />
<meta property="article:modified_time" content="2019-05-05T01:11:03+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Simple high value tests with Python Flask"/>
<meta name="twitter:description" content="After 6 years developing Python Flask applications, mainly REST API&rsquo;s, in 2019 I still could not find any good articles about how to develop high value tests for Python Flask based applications. That is going to change today!
First I will give my opinion on testing and methodology, followed by a demo case to illustrate high value testing with actual code. Feel free to skip all the boring reading and head directly over to the code on Github."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://cinaq.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cinaq.com/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://cinaq.com/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://cinaq.com/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://cinaq.com/">
				<img src="/images/xiwen.png" alt="CINAQ" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://cinaq.com/">CINAQ</a></h1>
	<div class="site-description"><p>Food for thought</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/xiwenc" title="Github"><i data-feather="github"></i></a></li><li><a href="http://nl.linkedin.com/in/xiwen" title="LinkedIn"><i data-feather="linkedin"></i></a></li><li><a href="https://www.twitter.com/xiwenc" title="Twitter"><i data-feather="twitter"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav><span class="scheme-toggle"><a href="#" id="scheme-toggle"></a></div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/post">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">05</span>
							<span class="rest">May 2019</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Simple high value tests with Python Flask</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>After 6 years developing <a href="http://flask.pocoo.org">Python Flask</a> applications, mainly REST API&rsquo;s, in 2019 I still could not find any good articles about how to develop high value tests for Python Flask based applications. That is going to change today!</p>
<p>First I will give my opinion on testing and methodology, followed by a demo case to illustrate high value testing with actual code. Feel free to skip all the boring reading and head directly over to the code on <a href="https://github.com/xiwenc/python-flask-app-testing">Github</a>.</p>
<p>The foundation described in this article is mainly focussed on early projects with limited resources like time and people effort. In these cases you want the lowest possible investment that will generate a high return in value. Note, however, that this is not a silver bullet.</p>
<h1 id="high-value-tests">High value tests</h1>
<p>As a software engineer that has built many microservices in the past, I have always believed that having integration tests in the early stages of a product is of utmost importance to detect issues and confirm assumptions. Nowadays it is rare to build fully self contained systems that do not interact with other external systems. This external system could be a webservice or perhaps a complicated library that renders PDF files.</p>
<p>My definition for &ldquo;High value tests&rdquo; is inspired by <a href="https://medium.com/table-xi/high-cost-tests-and-high-value-tests-a86e27a54df">High Cost Tests and High Value Tests</a>:
A test case that is <em>efficient</em> and <em>effective</em> that focusses on business logic <em>we</em> have implemented.</p>
<p>Let&rsquo;s dissect this statement. We want our tests to be <em>efficient</em>, because it is not funny to wait for hours for a test case to finish to discover it failed. Or it demands many resources like compute power or manual labor which could be very costly. <em>Effective</em> because we are only interested in interfacing with a third party library or web service but not their inner workings. Finally there is emphasis on <em>we</em>. Our system is often a composition of one or more other components working in harmony. Full complexity of systems are in fact all the code you have produced together with the code of all your dependencies and their dependencies. As you might have guessed already in practice systems are often very complicated. As we do not have access to infinite resources we have to get the most out of our investments so we test the interfaces of these external dependencies only.</p>
<p>In practice good test cases are a balance between depth (when do we include external dependencies), simplicity and flexibility.</p>
<h1 id="anatomy">Anatomy</h1>
<p>Following the <a href="http://wiki.c2.com/?ArrangeActAssert">AAA (Arrange, Act and Assert) pattern</a> we define the anatomy of a good high value test case to have the follow components:</p>
<ul>
<li><strong>Goal</strong>: Why are we writing this test?</li>
<li><strong>Arrange</strong>: What assumptions do we have if any?</li>
<li><strong>Act</strong>: Trigger the API endpoint or function call</li>
<li><strong>Assert</strong>: Verify expected results</li>
</ul>
<p>Other non-functional requirements are:</p>
<ul>
<li>Simplicity: someone with low programming skills should be able to extend or create new test cases based on existing ones</li>
<li>Fast: ideally the test case completes in milliseconds</li>
<li>Readability: conventional programming best practices should be applied to tests also, like short but descriptive variable names</li>
</ul>
<h1 id="example-simple-rest-api-with-flask">Example: Simple REST API with Flask</h1>
<p>Let&rsquo;s consider a simple Flask app that uses a hypothetical mail service implemented as <code>MailService</code>. Below is the file and directory structure of our application with 4 test cases implemented in 2 files (<code>test_errors.py</code> and <code>test_health.py</code>). We will dive deeper into the code in the rest of this section.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">├── README.md
├── app
│   ├── __init__.py
│   └── main.py
├── example_libs
│   ├── __init__.py
│   └── mail_service.py
├── requirements.txt
└── tests
    ├── __init__.py
    ├── base.py
    ├── test_errors.py
    └── test_health.py
</code></pre></div><p>In the app we have defined two REST endpoints:</p>
<ul>
<li>GET /health: responsible for reporting the health status of our app. The app&rsquo;s health is partly determined by whether we can communicate with the mail service. We do this by calling the <code>check()</code> method on the mail service instance.</li>
<li>PUT /error: throws a generic <code>Exception</code> simulating a runtime error.</li>
</ul>
<p>Here&rsquo;s actual source code <code>main.py</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">from</span> flask <span style="color:#00f">import</span> request, jsonify
<span style="color:#00f">from</span> flask <span style="color:#00f">import</span> Flask


<span style="color:#00f">class</span> <span style="color:#2b91af">App</span>(object):

    <span style="color:#00f">def</span> __init__(self, mail_service=None):

        <span style="color:#008000"># Create real service if not mocking</span>
        <span style="color:#00f">if</span> <span style="color:#00f">not</span> mail_service:
            <span style="color:#00f">from</span> example_libs.mail_service <span style="color:#00f">import</span> MailService
            mail_service = MailService()
        self.mail_service = mail_service

    <span style="color:#00f">def</span> create_app(self):
        app = Flask(__name__)
        app.app_context().push()

        @app.route(<span style="color:#a31515">&#34;/health&#34;</span>, methods=[<span style="color:#a31515">&#34;GET&#34;</span>])
        <span style="color:#00f">def</span> health():
            mail_service_health = self.mail_service.check()
            summary = {
                <span style="color:#a31515">&#34;mail_service&#34;</span>: mail_service_health,
            }
            <span style="color:#00f">return</span> jsonify(summary)

        @app.route(<span style="color:#a31515">&#34;/throw-exception&#34;</span>, methods=[<span style="color:#a31515">&#34;PUT&#34;</span>])
        <span style="color:#00f">def</span> error():
            <span style="color:#00f">raise</span> Exception(<span style="color:#a31515">&#34;An error has occurred&#34;</span>)

        <span style="color:#00f">return</span> app

<span style="color:#00f">if</span> __name__ == <span style="color:#a31515">&#34;__main__&#34;</span>:
    App().create_app().run()</code></pre></div>
<h1 id="test-suite">Test suite</h1>
<p>Test cases are often located in the <code>tests</code> directory. Each test case is implemented as a TestCase class. The below class diagram depicts the high level composition of such a TestCase.</p>
<p><img src="/media/diagrams/python-flask-app-testing-overview.png" alt="TestCase class diagram"></p>
<p>Our test suite contains 4 test cases grouped in 2 files. The test cases are all implemented according to the AAA principle.</p>
<h2 id="aaamixin">AAAMixin</h2>
<p>Before we start writing our test cases we first define our <code>AAAMixin</code> class which implements a basic structure according to the AAA methodology discussed earlier. We will use this mixin class later in our test cases. To void the <code>assert</code> keyword we write the main AAA methods which must be implemented by all test cases: <code>ARRANGE()</code>, <code>ACT()</code> and <code>ASSERT()</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">class</span> <span style="color:#2b91af">AAAMixin</span>(object):
    <span style="color:#a31515">&#34;&#34;&#34; Arrange, Act and Assert pattern &#34;&#34;&#34;</span>

    response = None
    client = None

    <span style="color:#00f">def</span> setUp(self):
        <span style="color:#a31515">&#34;&#34;&#34; Called after self.create_app() &#34;&#34;&#34;</span>
        self.client = self.app.test_client()
        <span style="color:#00f">return</span> super().setUp()

    <span style="color:#00f">def</span> ARRANGE(self):
        <span style="color:#00f">raise</span> NotImplementedError()

    <span style="color:#00f">def</span> ACT(self):
        <span style="color:#a31515">&#34;&#34;&#34; Use make call to live server and return the response
</span><span style="color:#a31515">
</span><span style="color:#a31515">        e.g. return self.client.get(&#34;/health&#34;)
</span><span style="color:#a31515">        &#34;&#34;&#34;</span>
        <span style="color:#00f">raise</span> NotImplementedError()

    <span style="color:#008000"># assert is a served keyword</span>
    <span style="color:#00f">def</span> ASSERT(self):
        <span style="color:#00f">raise</span> NotImplementedError()

    <span style="color:#00f">def</span> create_app(self):
        <span style="color:#00f">return</span> self.ARRANGE()

    <span style="color:#00f">def</span> test_case(self):
        <span style="color:#a31515">&#34;&#34;&#34; Single test case per test class &#34;&#34;&#34;</span>

        <span style="color:#008000"># Commented out because it is called by create_app(...) very early</span>
        <span style="color:#008000">#self._arrange()</span>
        self.response = self.ACT()
        self.ASSERT()</code></pre></div>
<p>The <code>AAAMixin</code> class is tightly coupled with the <code>LiveServerTestCase</code> class. Therefore the flow of execution differs a bit than conventional test cases. The following methods are executed in this order:</p>
<ul>
<li><code>create_app()</code>: returns the app created by <code>ARRANGE()</code>. This is needed because LiveServerTestCase expects this method to be implemented.
<ul>
<li><code>ARRANGE()</code>: to create the app, mocking if any have to be done in here</li>
</ul>
</li>
<li><code>setUp()</code>: extra setup steps, here we pre-create the <code>test_client</code></li>
<li><code>test_case()</code>: implicit test case. This is comparable to <code>main()</code> as main entry point but this is our test case and all test cases must start with <code>test_</code> prefix.
<ul>
<li><code>ACT()</code>: make call to API using <code>self.client</code> and return its response to <code>self.response</code>.</li>
<li><code>ASSERT()</code>: verify expected results by accessing <code>self.response</code>.</li>
</ul>
</li>
</ul>
<p>If we disregard non AAA related methods we will see that the AAAMixin forces us to stick to the AAA pattern. It is therefore sufficient for us to implement just these 3 methods to compose our test case.</p>
<h2 id="integration-test-health">Integration test: /health</h2>
<p>With the <code>AAAMixin</code> defined we can combine it with <code>LiveServerTestCase</code> from <code>flask_testing</code> package to write our first test case for <code>GET /health</code>. This test shows how we can use the AAA approach with a live server instance of our app to test against a real <code>MailService</code> instance.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">class</span> <span style="color:#2b91af">TestHealth_integration</span>(AAAMixin, LiveServerTestCase):
    <span style="color:#a31515">&#34;&#34;&#34; Test against real mail service integration &#34;&#34;&#34;</span>

    <span style="color:#00f">def</span> ARRANGE(self):
        self.expected_health = {<span style="color:#a31515">&#34;mail_service&#34;</span>: <span style="color:#a31515">&#34;OK&#34;</span>}
        <span style="color:#00f">return</span> App().create_app()

    <span style="color:#00f">def</span> ACT(self):
        <span style="color:#00f">return</span> self.client.get(<span style="color:#a31515">&#34;/health&#34;</span>)

    <span style="color:#00f">def</span> ASSERT(self):
        <span style="color:#00f">assert</span> self.response.status_code == HTTPStatus.OK
        <span style="color:#00f">assert</span> self.response.get_json() == self.expected_health</code></pre></div>
<h2 id="unit-test-health">Unit test: /health</h2>
<p>In a real world scenario the MailService could slow down our test. We could have a very limited set of integration tests of this service and mock it most of the time. Mocking is very useful because it&rsquo;s fast and that&rsquo;s were we set our boundaries of where we stop testing logic that was not implemented by us (with the assumption the third party library is well tested on its own).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">class</span> <span style="color:#2b91af">TestHealth_sick</span>(AAAMixin, LiveServerTestCase):
    <span style="color:#a31515">&#34;&#34;&#34; Detect when mail service is in sick state &#34;&#34;&#34;</span>

    <span style="color:#00f">def</span> ARRANGE(self):
        self.expected_health = {<span style="color:#a31515">&#34;mail_service&#34;</span>: <span style="color:#a31515">&#34;sick&#34;</span>}
        mocked_mail_service = mock.Mock(autospec=True)
        mocked_mail_service.check = mock.MagicMock(
            return_value=self.expected_health[<span style="color:#a31515">&#34;mail_service&#34;</span>],
        )
        <span style="color:#00f">return</span> App(
            mail_service=mocked_mail_service,
        ).create_app()

    <span style="color:#00f">def</span> ACT(self):
        <span style="color:#00f">return</span> self.client.get(<span style="color:#a31515">&#34;/health&#34;</span>)

    <span style="color:#00f">def</span> ASSERT(self):
        <span style="color:#00f">assert</span> self.response.status_code == HTTPStatus.OK
        <span style="color:#00f">assert</span> self.response.get_json() == self.expected_health</code></pre></div>
<h2 id="more-test-cases">More test cases</h2>
<p>To illustrate how easy and obvious it is to create more test cases we have implemented 2 more test cases to test for errors.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#00f">from</span> unittest <span style="color:#00f">import</span> mock
<span style="color:#00f">from</span> flask_testing <span style="color:#00f">import</span> LiveServerTestCase
<span style="color:#00f">from</span> http <span style="color:#00f">import</span> HTTPStatus

<span style="color:#00f">from</span> app.main <span style="color:#00f">import</span> App
<span style="color:#00f">from</span> tests.base <span style="color:#00f">import</span> AAAMixin


<span style="color:#00f">class</span> <span style="color:#2b91af">TestErrors_not_found</span>(AAAMixin, LiveServerTestCase):
    <span style="color:#a31515">&#34;&#34;&#34; Unknown path result in Not Found &#34;&#34;&#34;</span>

    <span style="color:#00f">def</span> ARRANGE(self):
        <span style="color:#00f">return</span> App().create_app()

    <span style="color:#00f">def</span> ACT(self):
        <span style="color:#00f">return</span> self.client.get(<span style="color:#a31515">&#34;/i-do-not-exist&#34;</span>)

    <span style="color:#00f">def</span> ASSERT(self):
        <span style="color:#00f">assert</span> self.response.status_code == HTTPStatus.NOT_FOUND


<span style="color:#00f">class</span> <span style="color:#2b91af">TestErrors_throw_exception</span>(AAAMixin, LiveServerTestCase):
    <span style="color:#a31515">&#34;&#34;&#34; Exceptions result in internal server error &#34;&#34;&#34;</span>

    <span style="color:#00f">def</span> ARRANGE(self):
        <span style="color:#00f">return</span> App().create_app()

    <span style="color:#00f">def</span> ACT(self):
        <span style="color:#00f">return</span> self.client.put(<span style="color:#a31515">&#34;/error&#34;</span>)

    <span style="color:#00f">def</span> ASSERT(self):
        <span style="color:#00f">assert</span> self.response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR</code></pre></div>
<h1 id="demo">Demo</h1>
<p>Enough text, let&rsquo;s see how all of this works:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">python3 -m venv venv
source ./venv/bin/activate
pip3 install -r requirements.txt
pip3 install -r test-requirements.txt
python -m pytest ./tests -v</code></pre></div>
<p>Example output:
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">=========================== test session starts ===========================
...
cachedir: .pytest_cache
rootdir: /Users/xcheng/private/git/flask-app-testing
collected 4 items

tests/test_errors.py::TestErrors_not_found::test_case PASSED        [ 25%]
tests/test_errors.py::TestErrors_throw_exception::test_case PASSED  [ 50%]
tests/test_health.py::TestHealth_sick::test_case PASSED             [ 75%]
tests/test_health.py::TestHealth_integration::test_case PASSED      [100%]

============================ warnings summary =============================
...
================== 4 passed, 2 warnings in 0.68 seconds ===================</code></pre></div></p>
<p>The two warnings are from the <code>jinja2</code> library version we are using.</p>
<h1 id="evaluation">Evaluation</h1>
<p>Our final test cases adhere to:</p>
<ul>
<li>AAA principles: explicit arrange, act &amp; assert; nothing else</li>
<li>Simplicity: implement 3 methods and you are good to go</li>
<li>Fast: runs in milliseconds and allows easy mocking of components</li>
<li>Readable: the structure is easy to understand</li>
</ul>
<p>With the ability to running our tests againt a live server over HTTP, this allows us to test our APIs in more depth. We also have the choice to decide how deep we wish to test, because of the ease of mocking individual pieces of our application. For this to work, our <code>App.create_app()</code> must be able to accept instances to be mocked. Alternatively, one could explore the possibility of monkey patching.</p>
<h1 id="conclusions">Conclusions</h1>
<p>This test suite is currently being used by a medium sized Python REST API service. It has sped up our development significantly, and onboarding new developers was a breeze.</p>
<p>Check out the code on <a href="https://github.com/xiwenc/python-flask-app-testing">Github</a></p>
<h1 id="future">Future</h1>
<p>In the future we will extend this simple REST API with MySQL database support. In the light of high value tests we will also extend the test suite with support for launching MySQL service to support our tests.
As our test suite grows, there will be demand for parallelization.</p>
<h1 id="references">References</h1>
<ul>
<li><a href="https://medium.com/@hakibenita/keeping-tests-dry-with-class-based-tests-in-python-e3f2d815124">https://medium.com/@hakibenita/keeping-tests-dry-with-class-based-tests-in-python-e3f2d815124</a></li>
<li><a href="https://medium.com/table-xi/high-cost-tests-and-high-value-tests-a86e27a54df">https://medium.com/table-xi/high-cost-tests-and-high-value-tests-a86e27a54df</a></li>
<li><a href="http://wiki.c2.com/?ArrangeActAssert">http://wiki.c2.com/?ArrangeActAssert</a></li>
<li><a href="http://softwaretestingfundamentals.com/unit-testing/">http://softwaretestingfundamentals.com/unit-testing/</a></li>
<li><a href="https://techbeacon.com/devops/6-best-practices-integration-testing-continuous-integration">https://techbeacon.com/devops/6-best-practices-integration-testing-continuous-integration</a></li>
<li><a href="https://hackernoon.com/low-effort-high-value-integration-tests-in-redux-apps-d3a590bd9fd5">https://hackernoon.com/low-effort-high-value-integration-tests-in-redux-apps-d3a590bd9fd5</a></li>
<li><a href="https://dev.to/lgraziani2712/the-value-of-unit-or-integration-testing-56i0">https://dev.to/lgraziani2712/the-value-of-unit-or-integration-testing-56i0</a></li>
</ul>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/python">python</a></li>
							
							<li><a href="/tags/flask">flask</a></li>
							
							<li><a href="/tags/python-flask">python-flask</a></li>
							
							<li><a href="/tags/testing">testing</a></li>
							
							<li><a href="/tags/tests">tests</a></li>
							
							<li><a href="/tags/rest">rest</a></li>
							
							<li><a href="/tags/aaa">AAA</a></li>
							
							<li><a href="/tags/quality">quality</a></li>
							
							<li><a href="/tags/tdd">TDD</a></li>
							
						</ul>
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'cinaq';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the </a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2019  © Copyright notice |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-74177616-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
