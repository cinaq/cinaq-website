<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on CINAQ</title>
    <link>/categories/development/</link>
    <description>Recent content in Development on CINAQ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 May 2020 13:37:00 +0000</lastBuildDate><atom:link href="/categories/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Speed up docker builds with distcc, ccache and kubernetes</title>
      <link>/posts/2020/05/10/speed-up-docker-builds-with-distcc-ccache-and-kubernetes/</link>
      <pubDate>Sun, 10 May 2020 13:37:00 +0000</pubDate>
      
      <guid>/posts/2020/05/10/speed-up-docker-builds-with-distcc-ccache-and-kubernetes/</guid>
      <description>For a recent project I had to write my own Orthanc plugin. To build this plugin I needed to build Orthanc from source. The official docker-images are assembled based on pre-built binaries. So I could not use them.
Orthanc Dockerfile The first step is create a Dockerfile that compiles Orthanc from source. Looking through the compilation instructions and inspired by the official docker images I have assembled the following Dockerfile:</description>
    </item>
    
    <item>
      <title>Debug shell script error: not found</title>
      <link>/posts/2019/05/29/debug-shell-script-error-not-found/</link>
      <pubDate>Wed, 29 May 2019 00:13:37 +0100</pubDate>
      
      <guid>/posts/2019/05/29/debug-shell-script-error-not-found/</guid>
      <description>Automation engineers often have boring tasks. Their job is to automate repetitive tasks. In the early days of Unix and Linux most automation is done with shell scripts. Nowadays we use higher level configuration management systems like Ansible, Puppet, Salt, etc replacing most of the erroneous scripts with poor error handling, lots of boiler code and more importantly high maintenance cost.
$ ./main.sh ./main.sh: 3: exec: ./external.sh: not found $ ls -l -rwxr-xr-x 1 xiwen xiwen 33 May 29 01:25 external.</description>
    </item>
    
    <item>
      <title>Simple high value tests with Python Flask</title>
      <link>/posts/2019/05/05/simple-high-value-tests-with-python-flask/</link>
      <pubDate>Sun, 05 May 2019 01:11:03 +0100</pubDate>
      
      <guid>/posts/2019/05/05/simple-high-value-tests-with-python-flask/</guid>
      <description>After 6 years developing Python Flask applications, mainly REST API&amp;rsquo;s, in 2019 I still could not find any good articles about how to develop high value tests for Python Flask based applications. That is going to change today!
First I will give my opinion on testing and methodology, followed by a demo case to illustrate high value testing with actual code. Feel free to skip all the boring reading and head directly over to the code on Github.</description>
    </item>
    
  </channel>
</rss>
